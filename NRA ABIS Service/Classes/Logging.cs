using Microsoft.VisualBasic.Devices;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Management;
using System.Threading;
using System.Web;


namespace NRA_ABIS_Service
{
    public class Logging
    {
        private string path = AppDomain.CurrentDomain.BaseDirectory;
        private string LogExceptionPath = @"\Exception_Log";
        private string LogExceptionFile = "AfisBackend_ExLog_{0}.txt";
        private string LogTransactionPath = @"\Transaction_Log";
        private string LogTransactionFile = "AfisBackend_TransLog_{0}.txt";
        private string LogRootPath = @"C:\TEMPTEST\Logs\AfisBackendService";

        private static bool CheckDirExist(string path)
        {
            bool exist = false;

            try
            {
                if (!Directory.Exists(path))
                {
                    Directory.CreateDirectory(path);
                    exist = true;
                }
                else
                {
                    exist = true;
                }

                return exist;
            }
            catch (Exception ex)
            {
                return exist;
            }
        }

        private static ReaderWriterLockSlim _readWriteLock = new ReaderWriterLockSlim();

        internal void WriteToTransactionLog(string msg)
        {

            _readWriteLock.EnterWriteLock();
            try
            {
                string path = LogRootPath;
                string fullPath = path + LogTransactionPath;

                // check if directory exist
                if (CheckDirExist(fullPath))
                {
                    string ExFileName = string.Format(LogTransactionFile, DateTime.Now.ToString("yyyyMMdd"));
                    string ExFile = Path.Combine(fullPath, ExFileName);

                    // Append text to the file
                    using (StreamWriter sw = File.AppendText(ExFile))
                    {
                        sw.WriteLine("====================================================");
                        string sTime = DateTime.Now.ToString();
                        sw.WriteLine(string.Format("Date \t\t: {0}", sTime));
                        sw.WriteLine(string.Format("Transaction \t: {0}", msg));
                        sw.Close();
                    }
                }
            }
            catch (Exception ex)
            {
                // Create an EventLog instance and assign its source.
                EventLog eventLog = new EventLog();
                eventLog.Source = "AfisBackendService";

                // Write an entry in the event log.
                eventLog.WriteEntry("This is a exception was generated by WriteToLog call. - " + ex.ToString(), EventLogEntryType.Warning, 1001);
            }
            finally
            {
                // Release lock
                _readWriteLock.ExitWriteLock();
            }
        }

        internal void WriteToDEBUGLog(string msg)
        {
            _readWriteLock.EnterWriteLock();

            try
            {
                string path = LogRootPath;
                string fullPath = path + @"\Logs\DEBUG_Log";

                // check if directory exist
                if (CheckDirExist(fullPath))
                {
                    string ExFileName = string.Format("2id_AfisBackendService_DEBUG_Log_{0}.txt", DateTime.Now.ToString("yyyyMMdd"));
                    string ExFile = Path.Combine(fullPath, ExFileName);

                    // Append text to the file
                    using (StreamWriter sw = File.AppendText(ExFile))
                    {
                        sw.WriteLine("====================================================");
                        string sTime = DateTime.Now.ToString();
                        sw.WriteLine(string.Format("Date \t\t: {0}", sTime));
                        sw.WriteLine(string.Format("Transaction \t: {0}", msg));
                        sw.Close();
                    }
                }
            }
            catch (Exception ex)
            {
                // Create an EventLog instance and assign its source.
                EventLog eventLog = new EventLog();
                eventLog.Source = "AfisBackendService";

                // Write an entry in the event log.
                eventLog.WriteEntry("This is a exception was generated by WriteToLog call. - " + ex.ToString(), EventLogEntryType.Warning, 1001);
            }
            finally
            {
                // Release lock
                _readWriteLock.ExitWriteLock();
            }
        }



        /**************** Anton's exception class ****************/
        /*********************************************************/

        //handle the exception
        internal void Handle_Exception(Exception ex)
        {
            Handle_Exception(ex, 1);
        }

        private void Handle_Exception(Exception ex, int CallId)
        {
            ManagementObjectSearcher osManagementObjectSearcher;
            ManagementObject osManagementObject;
            ComputerInfo osComputerInfo;

            string osQuery = string.Empty;
            string osName = string.Empty;
            string osVersion = string.Empty;

            string idMachineName = string.Empty;
            string idUserName = string.Empty;
            string idIs64BitOS = string.Empty;
            string idIs64BitProcess = string.Empty;
            string idProcessors = string.Empty;
            string idUserDomainName = string.Empty;

            string memMbUseage = string.Empty;
            string memMbTotalPhysical = string.Empty;
            string memMbTotalVirtual = string.Empty;
            string memMbAvailablePhysical = string.Empty;
            string memMbAvailableVirtual = string.Empty;

            string memGbUseage = string.Empty;
            string memGbTotalPhysical = string.Empty;
            string memGbTotalVirtual = string.Empty;
            string memGbAvailablePhysical = string.Empty;
            string memGbAvailableVirtual = string.Empty;

            char[] StackTraceDelimiter = new char[] { '\r', '\n' };

            string exMessage = string.Empty;
            string exMessageInner = string.Empty;

            string exTarget = string.Empty;
            string exReason = string.Empty;
            string exLocation = string.Empty;

            string exLogged = string.Empty;

            string msgLog = string.Empty;
            string msgDisplay = string.Empty;

            int MaxLength = 0;

            try
            {
                //get the operating system information
                osQuery = "SELECT * FROM Win32_OperatingSystem";
                osManagementObjectSearcher = new ManagementObjectSearcher(osQuery);
                osManagementObject = osManagementObjectSearcher.Get().Cast<ManagementObject>().FirstOrDefault();
                osName = osManagementObject.Properties["Caption"].Value.ToString();
                osVersion = osManagementObject.Properties["Version"].Value.ToString();

                //get the workstation properties
                idMachineName = System.Environment.MachineName;
                idUserName = System.Environment.UserName;
                idIs64BitOS = System.Environment.Is64BitOperatingSystem.ToString();
                idIs64BitProcess = System.Environment.Is64BitProcess.ToString();
                idProcessors = System.Environment.ProcessorCount.ToString();
                idUserDomainName = System.Environment.UserDomainName;

                //get the current memory in mb
                osComputerInfo = new Microsoft.VisualBasic.Devices.ComputerInfo();

                memMbTotalPhysical = ((double)osComputerInfo.TotalPhysicalMemory / (1024 * 1024)).ToString("###,###,###,###,###,###,###.000 MB");
                memMbTotalVirtual = ((double)osComputerInfo.TotalVirtualMemory / (1024 * 1024)).ToString("###,###,###,###,###,###,###.000 MB");

                memMbAvailablePhysical = ((double)osComputerInfo.AvailablePhysicalMemory / (1024 * 1024)).ToString("###,###,###,###,###,###,###.000 MB");
                memMbAvailableVirtual = ((double)osComputerInfo.AvailableVirtualMemory / (1024 * 1024)).ToString("###,###,###,###,###,###,###.000 MB");

                memMbUseage = ((double)GC.GetTotalMemory(false) / (1024 * 1024)).ToString("###,###,###,###,###,###,###.000 MB");

                MaxLength = GetMaxStringLength(memMbTotalPhysical, memMbTotalVirtual, memMbAvailablePhysical, memMbAvailableVirtual, memMbUseage);

                memMbTotalPhysical = FormatStringLength(memMbTotalPhysical, MaxLength);
                memMbTotalVirtual = FormatStringLength(memMbTotalVirtual, MaxLength);

                memMbAvailablePhysical = FormatStringLength(memMbAvailablePhysical, MaxLength);
                memMbAvailableVirtual = FormatStringLength(memMbAvailableVirtual, MaxLength);

                memMbUseage = FormatStringLength(memMbUseage, MaxLength);

                //get the current memory in gb
                memGbTotalPhysical = ((double)osComputerInfo.TotalPhysicalMemory / (1024 * 1024 * 1024)).ToString("###,##0.000 GB");
                memGbTotalVirtual = ((double)osComputerInfo.TotalVirtualMemory / (1024 * 1024 * 1024)).ToString("###,##0.000 GB");

                memGbAvailablePhysical = ((double)osComputerInfo.AvailablePhysicalMemory / (1024 * 1024 * 1024)).ToString("###,##0.000 GB");
                memGbAvailableVirtual = ((double)osComputerInfo.AvailableVirtualMemory / (1024 * 1024 * 1024)).ToString("###,##0.000 GB");

                memGbUseage = ((double)GC.GetTotalMemory(false) / (1024 * 1024 * 1024)).ToString("###,##0.000 GB");

                MaxLength = GetMaxStringLength(memGbTotalPhysical, memGbTotalVirtual, memGbAvailablePhysical, memGbAvailableVirtual, memGbUseage);

                memGbTotalPhysical = FormatStringLength(memGbTotalPhysical, MaxLength);
                memGbTotalVirtual = FormatStringLength(memGbTotalVirtual, MaxLength);

                memGbAvailablePhysical = FormatStringLength(memGbAvailablePhysical, MaxLength);
                memGbAvailableVirtual = FormatStringLength(memGbAvailableVirtual, MaxLength);

                memGbUseage = FormatStringLength(memGbUseage, MaxLength);

                //set the message variables
                exMessageInner = Get_Inner_Most_Exception(ex.InnerException, CallId);

                exMessage = ex.Message.Trim();

                if (!string.IsNullOrWhiteSpace(exMessageInner))
                {
                    exMessage += Environment.NewLine + exMessageInner;
                }

                //split the stack trace
                string[] StackTrace = ex.StackTrace.Split(StackTraceDelimiter, StringSplitOptions.RemoveEmptyEntries);

                if (StackTrace != null)
                {
                    switch (StackTrace.Length)
                    {
                        case 1:

                            exTarget = "Undetermined";
                            exReason = "Undetermined";
                            exLocation = StackTrace[0].Substring(6).Trim();

                            break;

                        case 2:

                            exTarget = "Undetermined";
                            exReason = StackTrace[0].Substring(6).Trim();
                            exLocation = StackTrace[1].Substring(6).Trim();

                            break;

                        case 3:

                            exTarget = StackTrace[0].Substring(6).Trim();
                            exReason = StackTrace[1].Substring(6).Trim();
                            exLocation = StackTrace[2].Substring(6).Trim();

                            break;

                        default:

                            exTarget = StackTrace[0].Substring(6).Trim();
                            exReason = StackTrace[1].Substring(6).Trim();
                            exLocation = StackTrace[2].Substring(6).Trim();

                            break;
                    }
                }
                else
                {
                    exTarget = "Undetermined";
                    exReason = "Undetermined";
                    exLocation = "Undetermined";
                }

                var st = new StackTrace(ex, true);
                var frame = st.GetFrame(0);
                var line = frame.GetFileLineNumber();
                var fullname = ex.GetType().FullName;

                //create the log exception message
                msgLog = "Encountered\t\t: " + System.DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss") +
                    Environment.NewLine +
                    Environment.NewLine + "Operating System\t: " + osName + " version " + osVersion +
                    Environment.NewLine + "64bit Operating System\t: " + idIs64BitOS +
                    Environment.NewLine + "64bit Process\t\t: " + idIs64BitProcess +
                    Environment.NewLine + "Number of Processors\t: " + idProcessors +
                    Environment.NewLine +
                    Environment.NewLine + "Machine Name\t\t: " + idMachineName +
                    Environment.NewLine + "User Domain Name\t: " + idUserDomainName +
                    Environment.NewLine + "User Name\t\t: " + idUserName +
                    Environment.NewLine +
                    Environment.NewLine + "Application Memory Useage\t: " + memMbUseage + "\t\t: " + memGbUseage +
                    Environment.NewLine +
                    Environment.NewLine + "Total Physical Memory\t\t: " + memMbTotalPhysical + "\t\t: " + memGbTotalPhysical +
                    Environment.NewLine + "Available Physical Memory\t: " + memMbAvailablePhysical + "\t\t: " + memGbAvailablePhysical +
                    Environment.NewLine +
                    Environment.NewLine + "Total Virtual Memory\t\t: " + memMbTotalVirtual + "\t\t: " + memGbTotalVirtual +
                    Environment.NewLine + "Available Virtual Memory\t: " + memMbAvailableVirtual + "\t\t: " + memGbAvailableVirtual +
                    Environment.NewLine +
                    Environment.NewLine + "Exception Name\t\t\t: " + fullname +
                    Environment.NewLine + "Exception Message\t\t: " + exMessage +
                    Environment.NewLine + "Exception Target\t\t: " + exTarget +
                    Environment.NewLine + "Exception Reason\t\t: " + exReason +
                    Environment.NewLine + "Exception Location\t\t: " + exLocation +
                    Environment.NewLine + "Exception Line\t\t\t: " + line;



                //write the exception to logs
                switch (LogException(msgLog, CallId))
                {
                    case true:

                        exLogged = "The exception was logged.";
                        break;

                    case false:

                        exLogged = "The exception could not be logged.";
                        break;
                }

                if (CallId == 1)
                {
                    //create the display exception message
                    msgDisplay = "The application encountered an exception." +
                        Environment.NewLine + Environment.NewLine +
                        "Message:" + Environment.NewLine + exMessage +
                        Environment.NewLine + Environment.NewLine +
                        "Reason:" + Environment.NewLine + exReason +
                        Environment.NewLine + Environment.NewLine +
                        "Location:" + Environment.NewLine + exLocation +
                        Environment.NewLine + Environment.NewLine +
                        exLogged;

                    //display the exception
                    //MessageBox.Show(msgDisplay,
                    //    this.Message_Box_Caption, MessageBoxButton.OK, MessageBoxImage.Warning);
                }
            }

            catch (Exception innerEx)
            {
                switch (CallId >= 1 && CallId <= 3)
                {

                    case true:

                        Handle_Exception(innerEx, CallId + 1);
                        break;

                    case false:

                        //set the message variables
                        exMessage = innerEx.Message;

                        //set the stack trace
                        string StackTrace = innerEx.StackTrace;

                        //create the display exception message
                        msgDisplay = "The application encountered an exception." +
                            Environment.NewLine + Environment.NewLine +
                            "The exception handler could not handle the application exception because the exception handler encountered an exception." +
                            Environment.NewLine + Environment.NewLine +
                            "Message:" + Environment.NewLine + exMessage +
                            Environment.NewLine + Environment.NewLine +
                            "Stack Trace:" + Environment.NewLine + StackTrace +
                            Environment.NewLine + Environment.NewLine +
                            "Check the logs to determine if this exception was logged.";

                        //display the exception
                        //MessageBox.Show(msgDisplay,
                        //    this.Message_Box_Caption, MessageBoxButton.OK, MessageBoxImage.Stop);

                        break;
                }
            }
        }

        //log the excpetion
        private bool LogException(string ExceptionMessage, int CallId)
        {
            try
            {
                string path = LogRootPath;
                string exFilePath = path + LogExceptionPath;

                CheckDirExist(exFilePath);

                //string ExFileName = string.Format("2id_BioService_ExLog_{0}.txt", DateTime.Now.ToString("yyyyMMdd"));
                string ExFileName = string.Format(LogExceptionFile, DateTime.Now.ToString("yyyyMMdd"));
                string ExFile = Path.Combine(exFilePath, ExFileName);


                int ReplaceStart = ExceptionMessage.IndexOf("Exception Message\t\t:");
                int ReplaceEnd = ExceptionMessage.IndexOf("Exception Target\t\t:");

                string ReplaceString = ExceptionMessage.Substring(ReplaceStart, ReplaceEnd - ReplaceStart - Environment.NewLine.Length).Replace(Environment.NewLine, Environment.NewLine + "\t\t\t" + ": ");

                ExceptionMessage = ExceptionMessage.Substring(0, ReplaceStart) + ReplaceString + Environment.NewLine + ExceptionMessage.Substring(ReplaceEnd);

                if (File.Exists(ExFile))
                {
                    Console.WriteLine(ExFile);
                    ExceptionMessage = Environment.NewLine + Environment.NewLine +
                        ExceptionMessage +
                        Environment.NewLine + Environment.NewLine +
                        "====================================================================================================";
                }
                else
                {
                    ExceptionMessage = "====================================================================================================" +
                        Environment.NewLine + Environment.NewLine +
                        ExceptionMessage +
                        Environment.NewLine + Environment.NewLine +
                        "====================================================================================================";
                }

                File.AppendAllText(ExFile, ExceptionMessage);

                return true;
            }

            catch (Exception innerEx)
            {
                switch (CallId >= 1 && CallId <= 3)
                {
                    case true:

                        Handle_Exception(innerEx, CallId + 1);
                        break;

                    case false:

                        //set the message variables
                        string exMessage = innerEx.Message;

                        //set the stack trace
                        string StackTrace = innerEx.StackTrace;

                        //create the display exception message
                        string msgDisplay = "The application encountered an exception." +
                            Environment.NewLine + Environment.NewLine +
                            "The exception handler could not handle the application exception because the exception handler encountered an exception." +
                            Environment.NewLine + Environment.NewLine +
                            "Message:" + Environment.NewLine + exMessage +
                            Environment.NewLine + Environment.NewLine +
                            "Stack Trace:" + Environment.NewLine + StackTrace +
                            Environment.NewLine + Environment.NewLine +
                            "Check the logs to determine if this exception was logged.";

                        //display the exception
                        //MessageBox.Show(msgDisplay,
                        //    this.Message_Box_Caption, MessageBoxButton.OK, MessageBoxImage.Stop);

                        break;
                }

                return false;
            }
        }

        //get the inner most exception
        private string Get_Inner_Most_Exception(Exception ex, int CallId)
        {
            string ReturnValue = string.Empty;

            try
            {
                while (ex != null)
                {
                    if (!string.IsNullOrWhiteSpace(ex.Message))
                    {
                        ReturnValue = ex.Message;
                    }

                    ex = ex.InnerException;
                }

                return ReturnValue;
            }

            catch (Exception innerEx)
            {
                Handle_Exception(innerEx, CallId + 1);
                return ReturnValue;
            }
        }

        //get the longest string length from the sent string values
        private int GetMaxStringLength(string Value01, string Value02, string Value03, string Value04, string Value05)
        {
            int MaxLength = 0;

            if (!string.IsNullOrWhiteSpace(Value01))
            {
                if (MaxLength < Value01.Length) MaxLength = Value01.Length;
            }

            if (!string.IsNullOrWhiteSpace(Value02))
            {
                if (MaxLength < Value02.Length) MaxLength = Value02.Length;
            }

            if (!string.IsNullOrWhiteSpace(Value03))
            {
                if (MaxLength < Value03.Length) MaxLength = Value03.Length;
            }

            if (!string.IsNullOrWhiteSpace(Value04))
            {
                if (MaxLength < Value04.Length) MaxLength = Value04.Length;
            }

            if (!string.IsNullOrWhiteSpace(Value05))
            {
                if (MaxLength < Value05.Length) MaxLength = Value05.Length;
            }

            //return the maximum length
            return MaxLength;

        }

        //make mb and gb strings fixed length
        private string FormatStringLength(string Value, int Length)
        {
            string FormatString = Value;

            for (int i = 1; i <= Length - Value.Length; i++)
            {
                FormatString = " " + FormatString;
            }

            return FormatString;
        }
    }
}